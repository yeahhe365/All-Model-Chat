聊天请求仍然走原始地址的增强修复方案：

=== 复制以下完整代码到控制台 ===

// 设置代理配置
localStorage.setItem('app-settings', JSON.stringify({
    useCustomApiConfig: true,
    apiProxyUrl: 'https://api-proxy.me/gemini',
    apiKey: 'AIzaSyCUduSy8NLnF0hKWjgial1Qtm8YQ6-LKr0',
    modelId: 'gemini-2.5-flash',
    temperature: 0.7,
    topP: 0.9,
    systemInstruction: '',
    showThoughts: false,
    thinkingBudget: 0,
    language: 'system',
    baseFontSize: 14,
    isStreamingEnabled: true,
    isAutoScrollOnSendEnabled: true,
    isAutoTitleEnabled: true,
    expandCodeBlocksByDefault: false,
    isMermaidRenderingEnabled: true,
    isGraphvizRenderingEnabled: true,
    isAutoSendOnSuggestionClick: true,
    isTranscriptionThinkingEnabled: false,
    transcriptionModelId: 'gemini-2.5-flash',
    ttsVoice: 'Puck',
    themeId: 'system'
}));

// 增强版拦截器 - 拦截所有可能的网络请求
console.log('🔧 启动增强版代理拦截器...');

// 1. 拦截 fetch
const originalFetch = window.fetch;
window.fetch = function(input, init = {}) {
    const url = typeof input === 'string' ? input : input.url;
    if (url && url.includes('generativelanguage.googleapis.com')) {
        const proxyUrl = url.replace('https://generativelanguage.googleapis.com/v1beta', 'https://api-proxy.me/gemini/v1beta');
        console.log('🔄 [FETCH] 代理请求:', url, '->', proxyUrl);
        const newInput = typeof input === 'string' ? proxyUrl : new Request(proxyUrl, input);
        return originalFetch(newInput, init);
    }
    return originalFetch(input, init);
};

// 2. 拦截 XMLHttpRequest
const originalXHROpen = XMLHttpRequest.prototype.open;
XMLHttpRequest.prototype.open = function(method, url, ...args) {
    if (typeof url === 'string' && url.includes('generativelanguage.googleapis.com')) {
        const proxyUrl = url.replace('https://generativelanguage.googleapis.com/v1beta', 'https://api-proxy.me/gemini/v1beta');
        console.log('🔄 [XHR] 代理请求:', url, '->', proxyUrl);
        return originalXHROpen.call(this, method, proxyUrl, ...args);
    }
    return originalXHROpen.call(this, method, url, ...args);
};

// 3. 拦截 EventSource (用于 SSE 流式请求)
const originalEventSource = window.EventSource;
window.EventSource = function(url, eventSourceInitDict) {
    if (typeof url === 'string' && url.includes('generativelanguage.googleapis.com')) {
        const proxyUrl = url.replace('https://generativelanguage.googleapis.com/v1beta', 'https://api-proxy.me/gemini/v1beta');
        console.log('🔄 [EventSource] 代理请求:', url, '->', proxyUrl);
        return new originalEventSource(proxyUrl, eventSourceInitDict);
    }
    return new originalEventSource(url, eventSourceInitDict);
};

// 4. 拦截 WebSocket (如果有使用)
const originalWebSocket = window.WebSocket;
window.WebSocket = function(url, protocols) {
    if (typeof url === 'string' && url.includes('generativelanguage.googleapis.com')) {
        const proxyUrl = url.replace('wss://generativelanguage.googleapis.com/v1beta', 'wss://api-proxy.me/gemini/v1beta')
                            .replace('ws://generativelanguage.googleapis.com/v1beta', 'ws://api-proxy.me/gemini/v1beta');
        console.log('🔄 [WebSocket] 代理请求:', url, '->', proxyUrl);
        return new originalWebSocket(proxyUrl, protocols);
    }
    return new originalWebSocket(url, protocols);
};

// 5. 拦截 navigator.sendBeacon (如果有使用)
if (navigator.sendBeacon) {
    const originalSendBeacon = navigator.sendBeacon;
    navigator.sendBeacon = function(url, data) {
        if (typeof url === 'string' && url.includes('generativelanguage.googleapis.com')) {
            const proxyUrl = url.replace('https://generativelanguage.googleapis.com/v1beta', 'https://api-proxy.me/gemini/v1beta');
            console.log('🔄 [SendBeacon] 代理请求:', url, '->', proxyUrl);
            return originalSendBeacon.call(this, proxyUrl, data);
        }
        return originalSendBeacon.call(this, url, data);
    };
}

// 6. 强制重写所有可能的网络函数
['fetch', 'XMLHttpRequest', 'EventSource', 'WebSocket'].forEach(api => {
    console.log(`✅ [增强拦截器] ${api} 已被拦截`);
});

console.log('✅ 增强版代理拦截器已激活，请刷新页面测试');
console.log('🎯 现在所有类型的网络请求都会被拦截并重定向到代理');

=== 操作步骤 ===
1. 全选上面的代码（从 // 设置代理配置 开始到最后）
2. 复制（Ctrl+C）
3. 在控制台中粘贴（Ctrl+V）
4. 按回车执行
5. 按F5刷新页面

这个增强版会拦截所有可能的网络请求类型，包括：
- fetch() 请求
- XMLHttpRequest 请求  
- EventSource (SSE流式请求)
- WebSocket 连接
- navigator.sendBeacon 请求

确保聊天的 streamGenerateContent 请求也会被正确代理！